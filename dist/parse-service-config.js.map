{"version":3,"sources":["../src/parse-service-config.ts"],"names":["parseServiceConfig","serverless","individually","_","get","packageIndividually","packageAllTogether","servicePath","config","functions","service","serviceFilesConfigArrPromises","map","name","serviceName","handler","custom","functionName","ncc","enabled","fileName","absPath","filePath","zipName","zipPath","path","join","perFunctionNccConfig","zip","files","serviceFilesConfigArr","Promise","all","filter","Boolean","getServiceName","Object","values","filesPromises"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport path from 'path';\nimport { handlerToFileDetails } from './utils';\nimport Serverless from 'serverless';\nimport { ServerlessFunctionDefinition, IFileNameAndPath } from './types';\nimport Service from 'serverless/classes/Service';\n\nexport default function parseServiceConfig(serverless: Serverless) {\n  const individually = !!_.get(serverless, 'service.package.individually');\n  if (individually) {\n    return packageIndividually(serverless);\n  }\n  return packageAllTogether(serverless);\n}\n\nexport interface IPackagingConfig {\n  functionName?: string;\n  zip: IFileNameAndPath;\n  files: IFileNameAndPath[];\n  perFunctionNccConfig?: Service.Custom;\n}\nasync function packageIndividually(serverless: Serverless): Promise<IPackagingConfig[]> {\n  const { servicePath } = serverless.config;\n  // @ts-ignore\n  const functions: { [key: string]: ServerlessFunctionDefinition } = serverless.service.functions;\n  const serviceFilesConfigArrPromises = _.map(\n    functions,\n    async ({ name: serviceName, handler, custom = {} }, functionName) => {\n      if (custom && custom.ncc && custom.ncc.enabled === false) {\n        return;\n      }\n\n      const { name: fileName, absPath: filePath } = await handlerToFileDetails(\n        servicePath,\n        handler,\n      );\n      const zipName = `${serviceName}.zip`;\n      const zipPath = path.join(servicePath, `.serverless/${zipName}`);\n      return {\n        perFunctionNccConfig: _.get(custom, 'ncc', {}),\n        functionName,\n        zip: {\n          absPath: zipPath,\n          name: zipName,\n        },\n        files: [\n          {\n            name: fileName,\n            absPath: filePath,\n          },\n        ],\n      };\n    },\n  );\n  const serviceFilesConfigArr = await Promise.all(serviceFilesConfigArrPromises);\n  return serviceFilesConfigArr.filter(Boolean) as IPackagingConfig[];\n}\n\nasync function packageAllTogether(serverless: Serverless): Promise<IPackagingConfig[]> {\n  const { servicePath } = serverless.config;\n  const zipName = `${serverless.service.getServiceName()}.zip`;\n  const zipPath = path.join(servicePath, `.serverless/${zipName}`);\n  // @ts-ignore\n  const functions: ServerlessFunctionDefinition[] = Object.values(serverless.service.functions);\n  const filesPromises = functions.map(async ({ handler }) => {\n    const { name, absPath } = await handlerToFileDetails(servicePath, handler);\n    return { name, absPath };\n  });\n  const files = await Promise.all(filesPromises);\n  return [{ zip: { name: zipName, absPath: zipPath }, files }];\n}\n"],"file":"parse-service-config.js"}