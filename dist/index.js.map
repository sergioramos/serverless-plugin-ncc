{"version":3,"sources":["../src/index.ts"],"names":["ServerlessPlugin","constructor","serverless","options","hooks","package","bind","packageFinalize","cli","log","servicePath","config","slsService","service","globalNccConfig","custom","ncc","dotServerlessPath","path","join","packageFilesConfig","packagingPromises","filter","Boolean","map","pkg","zip","files","perFunctionNccConfig","nccConfig","Object","assign","includeAssets","codeCompilePromises","absPath","inputFilePath","compiledCodes","Promise","all","compiledAssets","name","fullpath","source","permissions","mode","zipperFiles","createZipperFiles","zipPath","zipContents","setArtifacts","undefined","length","Error","content","forEach","push","data","file","index","compilerOutput","code","replace","assets","substring","lastIndexOf","keys","assetName","prototype","hasOwnProperty","call","serviceFilesConfigArr","individually","_","get","set","cnf","functionName","slsFunction","getFunction"],"mappings":"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","sourcesContent":["import { CompiledOutput } from '@zeit/ncc';\nimport _ from 'lodash';\nimport path from 'path';\nimport makeDir from 'make-dir';\nimport { readFile, stat } from 'mz/fs';\nimport Serverless from 'serverless';\n\nimport compiler from './compiler';\nimport parseServiceConfig, { IPackagingConfig } from './parse-service-config';\nimport { IFileNameAndPath, CompiledAsset } from './types';\nimport zipper, { ZipContent } from './zipper';\n\nexport default class ServerlessPlugin {\n  serverless: Serverless;\n  options: Serverless.Options;\n  hooks: { [key in string]: Function };\n  constructor(serverless: Serverless, options: Serverless.Options) {\n    this.serverless = serverless;\n    this.options = options;\n\n    this.hooks = {\n      'before:package:createDeploymentArtifacts': this.package.bind(this),\n      'before:package:finalize': this.packageFinalize.bind(this),\n    };\n  }\n\n  packageFinalize() {\n    this.serverless.cli.log('packageFinalize');\n  }\n\n  async package() {\n    this.serverless.cli.log('running ncc');\n    const { servicePath } = this.serverless.config;\n    const slsService = this.serverless.service;\n    const globalNccConfig = (slsService && slsService.custom && slsService.custom.ncc) || {};\n    const dotServerlessPath = path.join(servicePath, '.serverless');\n    await makeDir(dotServerlessPath);\n\n    const packageFilesConfig = await parseServiceConfig(this.serverless);\n    const packagingPromises = packageFilesConfig.filter(Boolean).map(async pkg => {\n      const { zip, files, perFunctionNccConfig = {} } = pkg;\n      const nccConfig = Object.assign({}, globalNccConfig, perFunctionNccConfig);\n      const { includeAssets = [] } = nccConfig;\n\n      // For now pass all ncc options directly to ncc. This has the benefit of testing out new\n      // ncc releases and changes quickly. Later it would be nice to add a validation step in between.\n      const codeCompilePromises = files.map(({ absPath }) =>\n        compiler({ inputFilePath: absPath, ...nccConfig }),\n      );\n\n      const compiledCodes = await Promise.all(codeCompilePromises);\n      const compiledAssets: CompiledAsset[] = await Promise.all(\n        includeAssets.map(\n          async (name: string): Promise<CompiledAsset> => {\n            const fullpath = path.join(servicePath, name);\n            return {\n              name,\n              source: await readFile(fullpath),\n              permissions: (await stat(fullpath)).mode,\n            };\n          },\n        ),\n      );\n\n      const zipperFiles = createZipperFiles(files, compiledCodes, compiledAssets.filter(Boolean));\n      await zipper({ zipPath: zip.absPath, zipContents: zipperFiles });\n    });\n    setArtifacts(this.serverless, packageFilesConfig);\n    await Promise.all(packagingPromises);\n    return undefined;\n  }\n}\n\nfunction createZipperFiles(\n  files: IFileNameAndPath[],\n  compiledCodes: CompiledOutput[],\n  compiledAssets: CompiledAsset[] = [],\n): ZipContent[] {\n  if (files.length !== compiledCodes.length) {\n    throw new Error('Expecting NCC output for all files.');\n  }\n\n  const content: ZipContent[] = [];\n\n  compiledAssets.forEach(({ name, source, permissions }) => {\n    return content.push({ name, mode: permissions, data: source });\n  });\n\n  files.forEach((file, index) => {\n    const compilerOutput = compiledCodes[index];\n\n    content.push({\n      data: compilerOutput.code,\n      // here we're replacing files with `.ts` extensions to `.js`\n      // as the `data` in the above live will already be a compiled JS file\n      name: file.name.replace(/.ts$/, '.js'),\n    });\n\n    if (compilerOutput.map) {\n      content.push({\n        data: compilerOutput.map,\n        // Make sure to rename the map the same way as the compiled output.\n        name: file.name.replace(/.ts$/, '.map.js'),\n      });\n    }\n\n    if (compilerOutput.assets) {\n      // Assets are relative to the 'code' file. But because of keeping the file\n      // structure in the zip output all assets need to be written to the same directory.\n      // The 'lastIndexOf() + 1' makes sure to keep the trailing slash.\n      const path = file.name.substring(0, file.name.lastIndexOf('/') + 1);\n\n      Object.keys(compilerOutput.assets).forEach(assetName => {\n        if (!Object.prototype.hasOwnProperty.call(compilerOutput.assets, assetName)) {\n          return;\n        }\n\n        content.push({\n          data: compilerOutput.assets![assetName].source,\n          name: `${path}${assetName}`,\n          mode: compilerOutput.assets![assetName].permissions,\n        });\n      });\n    }\n  });\n\n  return content;\n}\n\nfunction setArtifacts(serverless: Serverless, serviceFilesConfigArr: IPackagingConfig[]) {\n  const individually = !!_.get(serverless, 'service.package.individually');\n  if (!individually) {\n    _.set(serverless, 'service.package.artifact', serviceFilesConfigArr[0].zip.absPath);\n  } else {\n    for (const cnf of serviceFilesConfigArr) {\n      if (!cnf) {\n        continue;\n      }\n\n      const { functionName, zip } = cnf;\n      if (!functionName) {\n        throw new Error('functionName cannot be empty when packaging individually');\n      }\n      const slsFunction = serverless.service.getFunction(functionName);\n      _.set(slsFunction, 'package.artifact', zip.absPath);\n    }\n  }\n}\n"],"file":"index.js"}