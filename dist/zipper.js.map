{"version":3,"sources":["../src/zipper.ts"],"names":["createZip","zipPath","zipContents","zipStream","fs","createWriteStream","archive","zlib","level","Promise","resolve","reject","on","totalBytes","pointer","console","log","err","code","error","pipe","zipContent","append","data","name","mode","finalize"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;SAY8BA,S;;;;;iCAAf,WAAyB;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,GAAzB,EAAqE;AAClF,UAAMC,SAAS,GAAGC,YAAGC,iBAAH,CAAqBJ,OAArB,CAAlB;;AACA,UAAMK,OAAO,GAAG,uBAAS,KAAT,EAAgB;AAAEC,MAAAA,IAAI,EAAE;AAAEC,QAAAA,KAAK,EAAE;AAAT;AAAR,KAAhB,CAAhB;AAEA,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC;AACA;AACAR,MAAAA,SAAS,CAACS,EAAV,CAAa,OAAb,EAAsB,MAAM;AAC1B,cAAMC,UAAU,GAAGP,OAAO,CAACQ,OAAR,EAAnB;AACAC,QAAAA,OAAO,CAACC,GAAR,CAAa,GAAEH,UAAW,cAA1B;AACAE,QAAAA,OAAO,CAACC,GAAR,CAAY,wEAAZ;AACAN,QAAAA,OAAO,CAAC;AAAEG,UAAAA;AAAF,SAAD,CAAP;AACD,OALD,EAHsC,CAUtC;AACA;AACA;;AACAV,MAAAA,SAAS,CAACS,EAAV,CAAa,KAAb,EAAoB,MAAM;AACxBG,QAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ;AACD,OAFD,EAbsC,CAiBtC;;AACAV,MAAAA,OAAO,CAACM,EAAR,CAAW,SAAX,EAAsBK,GAAG,IAAI;AAC3B,YAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B,CACzB;AACD,SAFD,MAEO;AACL;AACA,gBAAMD,GAAN;AACD;AACF,OAPD,EAlBsC,CA2BtC;;AACAX,MAAAA,OAAO,CAACM,EAAR,CAAW,OAAX,EAAoBK,GAAG,IAAI;AACzBF,QAAAA,OAAO,CAACI,KAAR,CAAc,eAAd,EAA+BF,GAA/B;AACAN,QAAAA,MAAM,CAACM,GAAD,CAAN;AACD,OAHD,EA5BsC,CAiCtC;;AACAX,MAAAA,OAAO,CAACc,IAAR,CAAajB,SAAb;;AAEA,WAAK,MAAMkB,UAAX,IAAyBnB,WAAzB,EAAsC;AACpCI,QAAAA,OAAO,CAACgB,MAAR,CAAeD,UAAU,CAACE,IAA1B,EAAgC;AAC9BC,UAAAA,IAAI,EAAEH,UAAU,CAACG,IADa;AAE9BC,UAAAA,IAAI,EAAEJ,UAAU,CAACI;AAFa,SAAhC;AAID;;AAEDnB,MAAAA,OAAO,CAACoB,QAAR;AACD,KA5CM,CAAP;AA6CD,G","sourcesContent":["import fs from 'fs';\nimport archiver from 'archiver';\n\nexport type ZipContent = {\n  data: string | Buffer;\n  name: string;\n  mode?: number; // mode represents the permissions of the file\n}\n\ntype CreateZipOptions = {\n  zipPath: string;\n  zipContents: ZipContent[];\n};\nexport default async function createZip({ zipPath, zipContents }: CreateZipOptions) {\n  const zipStream = fs.createWriteStream(zipPath);\n  const archive = archiver('zip', { zlib: { level: 9 } });\n\n  return new Promise((resolve, reject) => {\n    // listen for all archive data to be written\n    // 'close' event is fired only when a file descriptor is involved\n    zipStream.on('close', () => {\n      const totalBytes = archive.pointer();\n      console.log(`${totalBytes} total bytes`);\n      console.log('archiver has been finalized and the output file descriptor has closed.');\n      resolve({ totalBytes });\n    });\n\n    // This event is fired when the data source is drained no matter what was the data source.\n    // It is not part of this library but rather from the NodeJS Stream API.\n    // @see: https://nodejs.org/api/stream.html#stream_event_end\n    zipStream.on('end', () => {\n      console.log('Data has been drained');\n    });\n\n    // good practice to catch warnings (ie stat failures and other non-blocking errors)\n    archive.on('warning', err => {\n      if (err.code === 'ENOENT') {\n        // log warning\n      } else {\n        // throw error\n        throw err;\n      }\n    });\n\n    // good practice to catch this error explicitly\n    archive.on('error', err => {\n      console.error('archive error', err);\n      reject(err);\n    });\n\n    // pipe archive data to the file\n    archive.pipe(zipStream);\n\n    for (const zipContent of zipContents) {\n      archive.append(zipContent.data, {\n        name: zipContent.name,\n        mode: zipContent.mode,\n      });\n    }\n\n    archive.finalize();\n  });\n}\n"],"file":"zipper.js"}